<center><font size=10><b>操作系统</b></font></center>
<center><font size=10><b>LAB 3 report</b></font></center>

<center><font size=5>王一鸣</font></center>

<center><font size=5>PB21000024</font></center>
# 实验目标

## 内存分配器

- 使用显式空闲链表实现一个64位堆内存分配器
  - 实现两种基本搜索算法  
  - 实现堆内存的动态扩容  
  - 实现实时的分配器内存使用情况统计  
- 学会以动态链接库的形式制作库并使用  
- 体会系统实验数据的测量和分析过程  

## linux内存管理信息统计

- 了解Linux系统虚拟内存的管理方式  
- 了解什么是VMA，并遍历、统计VMA 
- 了解Linux的多级页表机制  
- 了解Linux的页面置换算法，统计页面冷热并输出至图表观察  
- 了解用户内存地址空间的分布  

# 实验环境

- 实验机器：
  - cpu:11th Gen Intel(R) Core(TM) i5-1135G7 @ 2.40GHz   2.42 GHz
  - RAM:16GB
  - 操作系统：windows 10专业版22H2
- 虚拟环境：
  - 虚拟机：virtual box
  - 操作系统: ubuntu 20.04.6 LTS
  - 内核数：4
  - RAM:4GB
- 软件版本：
  - linux: 5.15.0-33

# 实验过程

## 内存分配器

内存分配器分为两个部分，一部分是用户程序向操作系统申请一定量的堆内存进行分配，另一部分是用户程序接受外部请求管理从操作系统申请的堆内存，相应的操作有分配内存，释放内存，重分配内存。

- 与操作系统的交互逻辑

  内存分配器无法在现有内存分配的情况下满足请求时，可以向操作系统申请一块新的内存加入到管理的内存空间中，实现堆内存的扩容。这里用到的关键数据结构是三个指针，分别指向操作系统分配的堆内存的底部和顶部，以及用户堆内存的顶部。

- 空闲链表

  空闲链表是管理用户堆空间的关键数据结构。对分配器来说，它需要知道每一块空闲的内存的位置和大小，以便于在接受请求后检查是否能满足请求，并将相应的地址位置传回给请求者。于是可以在空闲内存的端部标识空闲内存的大小，同时为了能够找到这些记录信息的端部，将其首尾相连串成一个链表，这样进行查找的时候只需要记住一端的地址就能找到所有的信息了。当然，这是为了最大化内存块分配的灵活性，其实也可以固定块的数目，专门划定一块区域来记录块的大小和位置，这样就可以实现对于块的随机访问，但同时，这种方法牺牲了内存分配的灵活性，当用户请求的内存次数多，容量小的情况下就很不实用。

- 空闲链表的合并逻辑

  实验中要求我们完成这个部分，在明晰了空闲链表的实现逻辑之后，这是很自然的。需要注意的是，宏定义的实现方式。对头部和尾部的取得是依赖于头部信息的，所以不能在修改其他信息之前就贸然修改头部（这里debug了好久），简单起见，修改某一位置时先把相关信息全部存在变量里面，这样就不会丢失信息了。

  - 前块未分配

    如果前块未分配的话，只需要简单的把当前块加到前面那块就行，具体就是修改前块头部和合并后的尾部即可

  - 后块未分配

    这个时候后块在空闲链表里，需要删去，其他地方的合并逻辑如上

  - 前后都分配

    相当于当前块变成了一个新空闲块，所以要加到空闲链表里

  所有这些改变都要记得，如果某一块的属性发生了改变，还要记得修改其后块，因为后块记录了前块是否分配的信息

  > mm_free下一块尾部不修改是因为在合并操作时，如果下一块是空闲块，那么自然尾部要修改，如果是分配块，无需尾部，所以两种情况都不需要在mm_free处修改尾部

- 分配块的逻辑

  在分配中，分配器总是搜寻空闲链表，找到某一块把它变成一块已分配的，和剩下的空闲剩余（如果有剩的话），而且由于要求返回的是输入的指针，所以必须把空闲块前面部分分配出去（因为分配后的指针要相同），所以这就造成了点麻烦，需要先把原先的空闲块从链表中删去（因为它的头部位置改变了，原来指的指针找不到了），然后产生新的空闲块信息再加回来，这个时候也要注意后块对前块是否分配的记录要更正

  > 如果不能构成一个空闲块，那么得修改后块的分配位

- 寻找块的逻辑

  寻找很简单，遍历空闲链表，first在找到第一个满足的就直接返回best就记录一个最小满足的地址，等遍历链表完了返回即可

## linux进程内存统计

linux进程页面统计这部分最关键在于理解进程内存组织的方式和结构，特别是虚拟地址和物理地址之间的映射关系即可，几个func是层层递进的，不妨顺着阐述一下。

- 统计vma

  首先，一个进程有若干个VMA，这些VMA以链表形式组织，所以取出进程结构体找到首个vma然后逐个遍历即可

- 遍历vma记录的页

  对于每一个vma，都记录了相应的虚拟地址的起始和末尾地址，所以只需要从起始地址，以页为粒度进行遍历，然后用referenced函数检查该page最近是否被访问过，把访问过的地址输出到文件中即可

  > 这里需要注意的一点就是得到的page有可能处于内核位置而无法访问，所以我们必须检查该页面地址是否合法，用宏is_erro_or_null判断，否则一访问就会产生奇奇怪怪的错误（在这里重启内核了好多次才发现），我的理解是非法地址是禁止用户访问的，可能处于内核态

- 进行虚拟地址到物理地址的转换

  这一步主要困难在于搞清楚几种宏的用法，输入输出的数据类型转换一定要搞明白才能正确的得到结果。进程有最高级的页表，能找到pgd的索引，根据虚拟地址的高位能够找到pgd真正的值，而该值指向的正是下一级页表的基地址，然后用虚拟地址的次高位作为偏移寻下一级，依次类推，找的时候要细细的检查找到的地址是否有效

  > 助教的文档给的有点小问题，最后一个页表判断是否有效的函数声明在库里面找不到，查了源码也没有，索性放掉了，好像也没有引起什么错误（）

- 查找代码段或者数据段

  这里其实跟前几部做的事情差不多，也是通过虚拟地址找实际的物理位置然后取数据，唯一不同的地方在于，代码段和数据段的地址是记录在进程结构体中的，而不是直接通过遍历vma得到的（我也试着直接顺着vma找，打出来的全是乱码），最后还是用进程指示的虚拟地址完成了。可能值得一说的是取数据时得按字节取数据（因为是数据段，字符类型的数据在这都是按字节保存的）。

  

# 实验结果

## 内存分配器

![image-20230601142817701](C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20230601142817701.png)

best_fit运行情况

![image-20230601143000662](C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20230601143000662.png)

first_fit运行情况

## linux进程页面统计

- func==1

![image-20230601143457947](C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20230601143457947.png)

- func==2

![image-20230601143348621](C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20230601143348621.png)

- func==3

![image-20230601143518108](C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20230601143518108.png)

如图所示，两两分组，上方是自己写的地址转换，下方是调用现成函数得到的地址转换

- func==4

![image-20230601143703642](C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20230601143703642.png)

- func==5

![image-20230601143724394](C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20230601143724394.png)

# 总结与收获

本次实验代码量不算大，重点在于理解了内存管理机制之后在真实的系统上进行操作，在这次的实验中，发现了以下几点问题：

- 代码管理：

  因为没有妥善记录代码的修改过程导致改来改去浪费了大量的时间，还是得学一学git的使用方法

- 指针的使用：

  内核态时对指针的使用必须非常小心，越界会造成各种不可知的错误，每次运行的时候先把代码保存好，方便追溯错误原因及时修改

更多的其实是一些细节上的收获，比如说调试程序的时候在哪些地方进行检测，设置条件语句打印相关信息，追踪某一个参数的变化，在调用的过程中一路把信息打印出来并转换成易于理解的形式。

实验的第二部分可以说的上是循序渐进了。开始觉得比较困难，两眼一抹黑，好在助教直接提供了一个hellow world的例子和运行脚本能够在啥也没干的时候直接能看到点输出，这些反馈对尝试中的初学者还是很重要的，然后逐步去编写程序对进程信息进行访问，先是vma的活跃信息，然后是vma对应的虚拟页和虚拟地址到物理地址的转换，最后是直接访问物理地址的内容，整个进程的组织结构在我脑海中一点一点清晰了起来。

当然在这个过程中也遇到不少困难，大部分是我自己粗心大意导致的，比如想当然判断页面是不是null就完了，没看到文档里面写的IS_ERRO_OR_NULL进行非法页面判断，这里就浪费了一个多小时，还有找代码段，直接去找进程第二个vma，结果找出一大堆乱码，最后也是查了文档问了同学才解决。

总而言之，本次实验让我对内存管理这部分有了一个outline，了解了真实的linux系统是如何管理内存的，算是有不少收获吧。

# 一些建议

- 对于代码填空，涉及到函数接口问题，比如输入输出参数，提供一些必要的说明可能可以节省一些时间

  当时在考虑块合并函数逻辑的时候看了好久，一开始想当然的写程序，出了一大堆bug，最后发现是默认的返回值出了点问题，但是找到这个问题需要把整个代码结构看清楚，某种程度上也帮助我理解了内存分配器orz

- 感觉linux页面统计这一部分，需要阅读的材料很多，但实际需要做的内容很少，几个function大多数代码都是重复的，不知道助教有没有考虑过把进程操作和进程信息结合起来，比如我在用户端实时运行一个进程，要求在内核态找到相应的信息，提供一些交互性可能会更有意思一些



