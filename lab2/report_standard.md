<center><font size=10><b>操作系统</b></font></center>
<center><font size=10><b>LAB 2 report</b></font></center>

<center><font size=5>王一鸣</font></center>

<center><font size=5>PB21000024</font></center>
# 实验目标

- 学习如何使用linux系统调用：实现简单的shell
  - 熟悉linux指令
  - 理解shell原理
  - 掌握linux-api系统调用的使用方法
  - 练习进程操作
  - 熟悉管道用法
- 学习如何添加linux系统调用：实现简单的top
  - 了解系统调用的建构过程
  - 了解系统内核态和用户态的概念

# 实验环境

- 实验机器：
  - cpu:11th Gen Intel(R) Core(TM) i5-1135G7 @ 2.40GHz   2.42 GHz
  - RAM:16GB
  - 操作系统：windows 10专业版22H2
- 虚拟环境：
  - 虚拟机：virtual box
  - 操作系统: ubuntu 20.04.6 LTS
  - 内核数：4
  - RAM:4GB
- 软件版本：
  - linux: 4.9.263
  - busybox:1.32.1

# 实验过程

## my_shell 实现

### 分析

- 思路

shell执行流程：

从命令行接受字符串->将命令按分号分解成多个命令开始执行->对于单个命令串检查是否是多个命令组合而成，将多个命令调用子进程进行执行

- 进程结构

主进程接受参数，执行内建指令

创建子进程执行execp命令，并通过主进程进行通信

- 关键部分
  - 命令执行
  - 重定向
  - 主进程控制

> 写的时候面临的主要困难是不知道有什么工具可以用来实现对应的功能，像chdir这种函数还是对着文档一条一条查才查出来的

### 过程

- 内建指令

![image-20230507141515098](C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20230507141515098.png)

内建指令必须放在父进程中改变父进程状态



- 重定向

![image-20230507141826493](C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20230507141826493.png)

接受从外部传入的管道端口描述符，重定向到对应的文件

比较有趣的地方是程序采用了循环处理命令串，对于没有被重定向的命令，修改传入的argv，相当于清除了多余的定向符，将指令覆盖原来的重定向，循环变量j最后就是指令数量

- 执行主函数

![image-20230507143737623](C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20230507143737623.png)

> 单个命令就不多赘述了

主函数的填空主要涉及到管道符的重定向，对多个管道符，基本的思路是将子进程分为三类

- 第一个进程

  第一个进程输入是标准输入，所以创建完管道之后只需要将标准输出重定向到第一次创建的管道的写端，然后记住这个管道的读端方便传给下一个进程，同时要关掉子进程的读写端，还有父进程的写端

- 中间的进程

  中间的进程从上一个进程创建的管道读数据，同时向自己创建的管道写数据，所以要将标准输入重定向到上一个管道的读端，标准输出重定向到当前管道的写端，关掉父进程对上一个管道的写端和当前管道的读端，当前子进程对当前管道的读写端

- 最后一个进程

  最后一个进程唯一的差别是输出是标准输出，并且不需要再创建管道，只需要关掉父进程关联的上一个管道读端即可

  > 单管道省略中间进程，其余是一致的



---

## my_top实现

### 分析

根据文档给出的例子，可以在内核态抓取信息，然后通过系统调用传递给用户态，再在用户态进行显示即可

### 过程

- 系统调用添加

先模仿给出的例子，遍历一遍process信息，并把信息储存起来传给用户态

![image-20230507150509186](C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20230507150509186.png)

相当于得到关于当前时刻所有进程的信息

- 用户函数编写

![image-20230507150755766](C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20230507150755766.png)

主要的思路就是接受内核态传来的信息，然后排序并加以显示即可

> 遇到的一个比较大的问题是一开始不知道是统计时间间隔，直接用总时间来进行排序的
>
> 为了不进行麻烦的修改，于是干脆用另一组变量存取了上一次状态的信息，每次计算的时候修改当前的信息，由于之前一直是对当前信息进行排序，所以程序的主要结构没有改变，省了许多麻烦

![image-20230507151237832](C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20230507151237832.png)

后面添加的比较函数，用于比较前后进程是否一致，并计算时间差，修改之后存在当前状态里，避免修改之前程序的结构

此外，cpu占用率算的是所有进程所占cpu时间中的比率，故总和一定是1

![image-20230507151710943](C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20230507151710943.png)

由于修改了很多次，写了个脚本偷懒

# 实验结果

![image-20230507152752682](C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20230507152752682.png)

重定向，将123424 和 12 输入temp.txt中

temp.txt文件内容如图所示

再用grep 123 读出数据得到 123424

多命令输出1  1  3

管道输出291统计了行数

![image-20230507153109521](C:\Users\86138\AppData\Roaming\Typora\typora-user-images\image-20230507153109521.png)

每一秒统计一次进程，按照占用率从高到低排序，效果如上

# 总结

- 对实验的一些认识
  - shell向我们展示了一个服务程序是如何和操作系统进行互动的，通过调用操作系统提供的各种系统调用我们就能进行调用各种资源，同时也巩固了进程的概念，进程之间的信息传递和操作在实现的过程中展现的很清晰
  - top向我们展示了系统调用是怎么建构的，操作系统是怎么向用户态提供信息，这里有两层，一个是提供了必要的信息，二是不许用户访问到不该访问的信息，于是采取这种严格区分系统内部变量和用户变量的机制，用户只能看到操作系统让其看到的信息

- 收获

  - 锻炼了读文档的能力

    linux的源码还是有点乱的，找了半天

    还有相关的系统调用

  - 了解了linux的结构

    算是对linux有了一个初步的认识，感觉还是很有趣的，特别是对一些以前理所当然视而不见的机制有了更深的认识

    比如标准库是怎么链接的，什么情况下才能使用

    真实的系统调用是怎么起作用的

- 问题

  主要是在一些没有可操作性的地方浪费了大量的时间，比如尝试管道和重定向的机制，还有几个内建函数的使用上面

  文档确实是给了这么些东西，但是真上手的时候还是有点懵，花了大量时间上网筛选信息，希望能给点提示会更高效一些

  特别是能像实现top的时候给个栗子，或者管道和重定向的时候，实际的编写一段程序，然后进行一些输入输出展示下效果

  可能会更易于接受

